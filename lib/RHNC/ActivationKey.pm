package RHNC::ActivationKey;

# $Id$

use warnings;
use strict;
use Params::Validate;
use Carp;

use base qw( RHNC );

use vars qw( %properties %valid_prefix );

=head1 NAME

RHNC::ActivationKey - The great new RHNC::ActivationKey!

=head1 VERSION

Version 0.01

=cut

our $VERSION = '0.01';

=head1 SYNOPSIS

Quick summary of what the module does.

Perhaps a little code snippet.

    use RHNC::ActivationKey;

    my $foo = RHNC::ActivationKey->new();
    ...

=head1 DESCRIPTION

A list of functions that can be exported.  You can delete this section
if you don't export anything, such as for a purely object-oriented module.

=head1 SUBROUTINES/METHODS

#    * string key - Leave empty to have new key autogenerated.
#    * string description
#    * string baseChannelLabel - Leave empty to accept default.
#    * int usageLimit - If unlimited usage is desired, use the create API that does not include the parameter.
#    * array:
#          o
#          o string - Add-on entitlement label to associate with the key.
#                + monitoring_entitled
#                + provisioning_entitled
#                + virtualization_host
#                + virtualization_host_platform
#    * boolean universalDefault

=cut

#
# Accessors
#
my %entitlements = map { $_ => 1 } qw(
  monitoring_entitled
  provisioning_entitled
  virtualization_host
  virtualization_host_platform
);

use constant {
    MANDATORY => 0,
    DEFAULT   => 1,
    VALIDATE  => 2,
    TRANSFORM => 3,
};

my %properties = (
    rhnc => [ 0, undef, undef, undef ],
    key  => [
        0,
        sub {
            my @t = ( 0 .. 9, 'a' .. 'f' );
            my $l = scalar @t;
            return join( '', map { $t[ rand $l ] } 1 .. 32 );
        },
        undef,
        undef
    ],
    description        => [ 1, undef, undef, undef ],
    base_channel_label => [ 0, q(),   undef, undef ],
    usage_limit        => [ 0, 0,     undef, undef ],
    entitlements       => [
        1,
        [],
        sub {
            foreach my $p (@_) {
                if ( !defined $entitlements{$p} ) { return 0; }
            }
            return 1;
        },
        undef
    ],
    universal_default => [ 1, $RHNC::_xmlfalse, undef, undef ],
    server_group_ids     => [ 0, [], undef, undef ],
    child_channel_labels => [ 0, [], undef, undef ],
    packages             => [ 0, [], undef, undef ],
    package_names        => [ 0, [], undef, undef ],
);

sub _setdefaults {
    my ( $self, @args ) = @_;

    foreach ( keys %properties ) {
        if ( ref $properties{$_}[DEFAULT] eq 'CODE' ) {
            $self->{$_} = $properties{$_}[DEFAULT]();
        }
        else {
            $self->{$_} = $properties{$_}[DEFAULT];
        }
    }
    return $self;
}

=head2 new

Create and return a new activation key.

  $ak = RHNC::ActivationKey->new(
    rhnc => $rhnc,
    key  => $key,    # optional, if empty/undefined, a random key is set
    description       => $description,
    universal_default => $bool,          # true (!=0) or false (0)

    base_channel_label => $base_channel_label,    # optional
    usage_limit        => $usage_limit,           # optional
    entitlements       => [
        qw(   monitoring_entitled provisioning_entitled
          virtualization_host virtualization_host_platform)
    ],    # optional, zero or more values
    server_group_ids     => [ $id1,   $id2, ],      # optional
    child_channel_labels => [ $chan1, $chan2, ],    # optional
    packages             => [ $pkg1,  $pkg2, ],     # optional
  );

=cut

sub new {
    my ( $class, @args ) = @_;
    $class = ref($class) || $class;

    my $self = {};
    bless $self, $class;

    # populate object from defaults
    $self->_setdefaults();

    my %v = map { $_ => 0 } ( keys %properties );

    # validate args given
    my %p = validate( @args, \%v );

    # populate object from @args
    for my $i ( keys %properties ) {
        if ( defined $p{$i} ) {
            $self->{$i} = $p{$i};
        }
    }

    if ( !ref( $self->{universal_default} ) ) {
        if ( $self->{universal_default} ) {
            $self->{universal_default} = $RHNC::_xmltrue;
        }
        else {
            $self->{universal_default} = $RHNC::_xmlfalse;
        }
    }

    if ( defined $self->{rhnc} ) {
        $self->{rhnc}->manage($self);
    }

    return $self;
}

=head2 name

Return activation key name (key).

    $name = $ak->name;

=cut

sub name {
    my ( $self, @args ) = @_;
    my $prev = q();

    if ( defined $self->{key} ) {
        $prev = $self->{key};
    }
    if (@args) {
        $self->{key} = shift @args;
        $self->set_details();
    }
    return $prev;
}

=head2 description

Return activation key's description.

  $description = $ak->description;

=cut

sub description {
    my ( $self, @args ) = @_;
    my $prev = q();

    if ( defined $self->{description} ) {
        $prev = $self->{description};
    }
    if (@args) {
        $self->{description} = shift @args;
        $self->set_details();
    }
    return $prev;
    my ( $self, @p ) = @_;

    return $self->{description};
}

=head2 universal_default

Return true if activation key is universal default, false otherwise.

  $is_default = $ak->universal_default;

=cut

sub universal_default {
    my ( $self, @args ) = @_;
    my $prev = q();

    if ( defined $self->{universal_default} ) {
        $prev = $self->{universal_default}->value();
    }
    if (@args) {
        $self->{universal_default} = shift @args;
        # Normalize now
        if ( !ref( $self->{universal_default} ) ) {
            if ( $self->{universal_default} ) {
                $self->{universal_default} = $RHNC::_xmltrue;
            }
            else {
                $self->{universal_default} = $RHNC::_xmlfalse;
            }
        }

        $self->set_details();
    }
    return $prev;
}

=head2 base_channel

Return activation key's base channel.

  $label = $ak->base_channel;

=cut

sub base_channel {
    my ( $self, @args ) = @_;
    my $prev = q();

    if ( defined $self->{base_channel_label} ) {
        $prev = $self->{base_channel_label};
    }
    if (@args) {
        $self->{base_channel_label} = shift @args;
        $self->set_details();
    }
    return $prev;
}

=head2 entitlements

Return array ref on entitlements for the activation key.

  $entitlements = $ak->entitlements;

=cut

sub entitlements {
    my ( $self, @args ) = @_;
    my $prev = \[];

    if ( defined $self->{entitlements} ) {
        $prev = $self->{entitlements};
    }

    if (@args) {
        my $c = shift @args;
        if ( $c eq 'add' ) {
            $self->{rhnc}->call( 'activationkey.addEntitlements', shift @args );
        }
        elsif ( $c eq 'remove' ) {
            $self->{rhnc}
              ->call( 'activationkey.removeEntitlements', shift @args );
        }
        elsif ( $c eq 'set' ) {
            $self->entitlements( 'remove' => $self->{entitlements} );
            $self->entitlements( 'add' => shift @args ) if @args;
        }
        elsif ( ref $c eq 'ARRAY' ) {

            # same as set
            $self->entitlements( 'remove' => $self->{entitlements} );
            $self->entitlements( 'add' => $c ) if @$c;
        }
    }
    return $prev;
}

=head2 server_group_ids

Return array ref on group ids for the activation key.

  $server_group_ids = $ak->server_group_ids;

=cut

sub server_group_ids {
    my ($self) = @_;

    if ( defined $self->{server_group_ids} ) {
        return $self->{server_group_ids};
    }
    return \[];
}

=head2 system_groups

Return array ref on system groups for the activation key.

  $system_groups_ref = $ak->system_groups;

=cut

sub system_groups {
    my ( $self, @args ) = @_;
    my @groups;
    my $prev;

    my $aksg = $self->{server_group_ids};
    if ( defined $aksg ) {
        foreach my $sgid (@$aksg) {
            my $sg = RHNC::SystemGroup->get( $self->{rhnc}, $sgid );
            push @groups, $sg->name();
        }
        $prev = \@groups;
    }

    if (@args) {
        my $c      = shift @args;
        my $sg_ref = shift @args;

        if ( $c eq 'add' && ref $sg_ref eq 'ARRAY' ) {
            my @sgids;
            foreach my $sg (@$sg_ref) {
                if ( RHNC::SystemGroup::is_system_group_id $sg ) {
                    push @sgids, $sg;
                }
                else {
                    my $sgo = RHNC::SystemGroup->get( $self->{rhnc}, $sg );
                    push @sgids, $sgo->id if defined $sgo;
                }
            }
            $self->{rhnc}
              ->call( 'activationkey.addServerGroups', $self->{key}, \@sgids );
        }
        elsif ( $c eq 'remove' && ref $sg_ref eq 'ARRAY' ) {
            my @sgids;
            foreach my $sg (@$sg_ref) {
                if ( RHNC::SystemGroup::is_system_group_id($sg) ) {
                    push @sgids, $sg;
                }
                else {
                    my $sgo = RHNC::SystemGroup->get( $self->{rhnc}, $sg );
                    push @sgids, $sgo->id if defined $sgo;
                }
            }

            $self->{rhnc}->call( 'activationkey.removeServerGroups',
                $self->{key}, \@sgids );
        }
        elsif ( $c eq 'set' && ref $sg_ref eq 'ARRAY' ) {
            $self->system_groups( 'remove' => $self->{server_group_ids} );
            $self->system_groups( 'add'    => $sg_ref );
        }
        elsif ( ref $c eq 'ARRAY' ) {
            $self->system_groups( 'remove' => $self->{server_group_ids} );
            $self->system_groups( 'add' => $c ) if @$c;
        }
    }

    return $prev;
}

=head2 child_channels

Return array ref on group ids for the activation key, modify if 

  $child_channels = $ak->child_channel;

  $child_channels = $ak->child_channels( add => [qw( label1 label2 )] );
  $child_channels = $ak->child_channels( remove => [qw( label1 label2 )] );
  $child_channels = $ak->child_channels( set => [qw( label1 label2 )] ); 
  $child_channels = $ak->child_channels( [qw( label1 label2)] ); # same as set

=cut

sub child_channels {
    my ( $self, @args ) = @_;
    my $prev = \[];
    my $chan_ref;

    if ( defined $self->{child_channel_labels} ) {
        $prev = $self->{child_channel_labels};
    }
    if (@args) {
        my $c = shift @args;
        $chan_ref = shift @args;

        if ( $c eq 'add' && ref $chan_ref eq 'ARRAY' ) {
            $self->{rhnc}->call( 'activationkey.addChildChannels',
                $self->{key}, $chan_ref );
        }
        elsif ( $c eq 'remove' && ref $chan_ref eq 'ARRAY' ) {
            $self->{rhnc}->call( 'activationkey.removeChildChannels',
                $self->{key}, $chan_ref );
        }
        elsif ( $c eq 'set' && ref $chan_ref eq 'ARRAY' ) {
            $self->child_channels( 'remove' => $self->{child_channel_labels} );
            $self->child_channels( 'add'    => $chan_ref );
        }
        elsif ( ref $c eq 'ARRAY' ) {
            $self->child_channels( 'remove' => $self->{child_channel_labels} );
            $self->child_channels( 'add' => $c ) if @$c;
        }
    }
    return $prev;
}

=head2 usage_limit

  $usage_limit = $ak->usage_limit;

=cut

sub usage_limit {
    my ( $self, @args ) = @_;
    my $prev = 0;

    if ( defined $self->{usage_limit} ) {
        $prev = $self->{usage_limit};
    }
    if (@args) {
        $self->{usage_limit} = shift @args ? $RHNC::_xmltrue : $RHNC::_xmlfalse;
        $self->set_details;
    }
    return $prev;
}

=head2 packages

Return or set packages.

  $pkg_array_ref = $ak->packages;

=cut

sub packages {
    my ( $self, @args ) = @_;
    my $prev = \[];

    if ( defined $self->{package_names} ) {
        $prev = $self->{package_names};
    }
    if ( @args == 2 ) {
        my $c           = shift @args;
        my $pkglist_ref = shift @args;

        my @pkglist;
        foreach my $p (@$pkglist_ref) {
            my ( $n, $v, $r, $a ) = RHNC::Package::split_package_name($p);
            push @pkglist,
              {
                name => RHNC::Package::join_package_name(
                    { name => $n, version => $v, release => $r }
                ),
                ( defined $a ? ( arch => $a ) : () )
              };
        }

        if ( $c eq 'add' && ref $pkglist_ref eq 'ARRAY' ) {
            $self->{rhnc}
              ->call( 'activationkey.addPackages', $self->{key}, \@pkglist );
        }
        elsif ( $c eq 'remove' && ref $pkglist_ref eq 'ARRAY' ) {
            $self->{rhnc}
              ->call( 'activationkey.removePackages', $self->{key}, \@pkglist );
        }
        elsif ( $c eq 'set' && ref $pkglist_ref eq 'ARRAY' ) {
            $self->packages( 'remove' => $self->{package_names} );
            $self->packages( 'add'    => $pkglist_ref );
        }
        elsif ( ref $c eq 'ARRAY' ) {
            $self->packages( 'remove' => $self->{package_names} );
            $self->packages( 'add' => $c ) if @$c;
        }
    }
    return $prev;
}

=head2 create

Create a new activation key.

    $ak->create();
    $ak = RHNC::ActivationKey->create(
        rhnc               => $rhnc,
        key                => $keyname,       # optional or can be empty
        description        => $description,
        base_channel_label => $channel,       # optional or can be empty
        universal_default  => $bool,
        entitlements       => [
            qw( monitoring_entitled provisioning_entitled
              virtualization_host virtualization_host_platform )
        ],
        usage_limit => $bool,
    );

=cut

sub _missing_parameter {
    my $parm = shift;

    croak "Missing parameter $parm";
}

sub create {
    my ( $self, @args ) = @_;

    if ( !ref $self ) {
        $self = __PACKAGE__->new(@args);
    }

    if ( defined $self->{rhnc} ) {
        $self->{rhnc}->manage($self);
    }

    foreach my $p (qw( )) {
        if ( !defined $self->{$p} ) {
            _missing_parameter($p);
        }
    }

    croak 'No RHNC client to persist to, exiting'
      if !defined $self->{rhnc};

    my $res = $self->{rhnc}->call(
        'activationkey.create', $self->{key},
        $self->{description},   $self->{base_channel_label},
        $self->{entitlements},  $self->{universal_default},
    );
    croak 'Create did not work' if !defined $res;
    $self->{key} = $res;

    return $self;
}

=head2 destroy 

=cut

sub destroy {
    my ( $self, @args ) = @_;

    my $res = $self->{rhnc}->call( 'activationkey.delete', $self->{key} );

    undef $self;

    return 1;
}

=head2 list

=cut

sub list {
    my ( $self, @p ) = @_;
    my $rhnc;

    if ( ref $self eq 'RHNC::ActivationKey' && defined $self->{rhnc} ) {

        # OO context, eg $ak-list
        $rhnc = $self->{rhnc};
    }
    elsif ( ref $self eq 'RHNC::Session' ) {

        # Called as RHNC::ActivationKey::List($rhnc)
        $rhnc = $self;
    }
    elsif ( $self eq __PACKAGE__ && ref( $p[0] ) eq 'RHNC::Session' ) {

        # Called as RHNC::ActivationKey->List($rhnc)
        $rhnc = shift @p;
    }
    else {
        croak "No RHNC client given here";
    }

    my $res = $rhnc->call('activationkey.listActivationKeys');

    my @l;
    foreach my $o (@$res) {
        push @l, RHNC::ActivationKey->new($o);
    }

    return @l;
}

=head2 get

=cut

sub get {
    my ( $self, @p ) = @_;
    my $rhnc;

    if ( ref $self eq __PACKAGE__ && defined $self->{rhnc} ) {

        # OO context, eg $ak-list
        $rhnc = $self->{rhnc};
    }
    elsif ( ref $self eq 'RHNC::Session' ) {

        # Called as RHNC::ActivationKey::List($rhnc)
        $rhnc = $self;
    }
    elsif ( $self eq __PACKAGE__ ) {

        # Called as RHNC::ActivationKey->List($rhnc)
        $rhnc = shift @p;
    }
    else {
        croak "No RHNC client given";
    }

    my $k = shift @p
      or croak "No activation key specified in get";

    my $res = $rhnc->call( 'activationkey.getDetails', $k );

    if ( defined $res ) {
        my $ak = __PACKAGE__->new( %{$res} );
        $rhnc->manage($ak);
        return $ak;
    }
    return;
}

=head2 set_details

Update details of an activation key (description, base_channel,
usage_limit, universal_default).

=cut

sub set_details {
    my ($self) = @_;

    $self->{rhnc}->call(
        'setDetails',
        {
            description        => $self->{description},
            base_channel_label => $self->{base_channel_label},
            usage_limit        => $self->{usage_limit},
            universal_default  => $self->{universal_default},
        }
    );

}

=head2 as_string

Returns a printable string to describe activation key.

    print $ak->as_string;

=cut

sub as_string {
    my ($self) = @_;

    my $output;

    $output = "key: " . $self->name();
    $output .= "\n  description: " . $self->description();
    $output .= "\n  base_channel: " . $self->base_channel();
    $output .= "\n  entitlements: " . join( ',', @{ $self->entitlements() } );
    $output .= "\n  universal_default: " . $self->universal_default();
    $output .= "\n  package_names: " . join( ',', @{ $self->packages() } );
    $output .= "\n  usage_limit: " . $self->usage_limit();
    $output .=
      "\n  server_group_ids: " . join( ',', @{ $self->server_group_ids() } );
    $output .= "\n  system_groups: " . join( ',', @{ $self->system_groups() } );
    $output .=
      "\n  child_channels: " . join( ',', @{ $self->child_channels() } );
    $output .= "\n";

    return $output;
}

=head1 DIAGNOSTICS

=head1 CONFIGURATION AND ENVIRONMENT

=head1 DEPENDENCIES

=head1 INCOMPATIBILITIES

=head1 BUGS AND LIMITATIONS

Please report any bugs or feature requests to C<bug-rhn-session at rt.cpan.org>, or through
the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=RHNC-Session>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.

=head1 AUTHOR

Jérôme Fenal, C<< <jfenal at redhat.com> >>


=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc RHNC::ActivationKey


You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=RHNC-Session>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/RHNC-Session>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/RHNC-Session>

=item * Search CPAN

L<http://search.cpan.org/dist/RHNC-Session/>

=back


=head1 ACKNOWLEDGEMENTS


=head1 LICENSE AND COPYRIGHT

Copyright 2009 Jérôme Fenal, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


=cut

1;    # End of RHNC::ActivationKey
