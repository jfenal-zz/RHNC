#!/usr/bin/perl
#
# $Id$
#

use strict;
use warnings;

use lib qw( . .. lib ../lib );
use RHNC;
use RHNC::Session;
use RHNC::Channel;
use Carp;
use Getopt::Long qw(GetOptionsFromArray);
use Data::Dumper;

use vars qw( $rhnc );

=head1 NAME

rhnc-kickstart - Operate on Satellite managed kickstarts.

=head1 USAGE

  rhnc-kickstart command [options or parameters]

=head1 REQUIRED ARGUMENTS

At least command is required for this script to operate. No shell is
currently offered, although this may come in the future.

=head1 DESCRIPTION

The following commands are available:

=head2 add_packages

TODO

=cut

sub add_packages {
    carp "not implemented yet";

    return;
}

sub create {
    my @args = @_;

    # FIXME : this cannot work as it is. Add argument parsing here
    # using Getopt::Long
    my $rc = RHNC::Channel->create( rhnc => $rhnc, @args );

    return $rc;
}

sub destroy {
    my @args = @_;

    foreach my $kname (@args) {
        my $chan = RHNC::Channel->get( $rhnc, $kname );
        if ( defined $chan ) {
            $chan->delete( $rhnc, $kname );
        }
    }

    return 1;
}

=head2 gdp|get_detail_packages

Print details for packages in the channel.

=cut

sub get_detail_packages {
    my (@args) = @_;

    foreach my $chan (@args) {
        my $channel = RHNC::Channel::get( $rhnc, $chan );

        print 'Packages for channel '
          . $channel->label . ' ('
          . $channel->name() . ")\n";
        my @plist = $channel->packages();
        @plist = sort {
            "$a->{name}-$a->{version}-$a->{release}-$a->{arch_label}" cmp
              "$b->{name}-$b->{version}-$b->{release}-$b->{arch_label}"
        } @plist;

        #@plist = sort { $a->{last_modified} cmp $b->{last_modified} } @plist;
        foreach my $p (@plist) {
            print "  $p->{name}-$p->{version}-$p->{release}-$p->{arch_label}: ";
            print join ", ", map { "$_=$p->{$_}" } qw( id last_modified);
            print "\n";
        }
    }

    return 1;
}

=head2 gd|get_details

Print detailed information about the given channel(s).

=cut

sub get_details {
    my @args = @_;

    my $chan;
    while ( $chan = shift @args ) {
        print "$chan:\n";
        my $channel = RHNC::Channel::get( $rhnc, $chan );
        $channel->nbpackages();
        foreach my $k ( sort ( keys %{$channel} ) ) {
            next if $k eq 'rhnc';
            if ( $k eq 'packages' ) {
                print "$k: ";
                my %pkg = map { $_->{name} => 1 } @{ $channel->{$k} };
                print join( ', ', sort keys %pkg );
                print "\n";
            }
            else {
                print "  $k : $channel->{$k}\n";
            }
        }
    }

    return 1;
}

=head2 l|list

List channels

=cut

sub list {
    my @args = @_;
    my ($verbose);

    my $result = GetOptionsFromArray( \@args, 'verbose|v' => \$verbose, );

    my @channel = RHNC::Channel->list($rhnc);

    my $nr = 0;
    foreach my $chan (@channel) {
        my $parent = $chan->parent_label();
        my $child  = $chan->label();
        if ( $parent ne q() ) { print q(  ); }
        printf(
            "%-44s: %5d pkg, %5d systems, %s, %-40s\n",
            $chan->label(),         $chan->nbpackages(), $chan->systems(),
            $chan->provider_name(), $chan->name(),
        );
    }
    print "\nTotal: " . scalar(@channel) . " Channels\n";

    return 1;
}

=head2 la|list_arches

Prints a list of available arches.

=cut

sub list_arches {
    my @args = @_;

    my %arches = RHNC::Channel->list_arches($rhnc);

    print "Arches available: \n";
    foreach my $a ( keys %arches ) {
        print "$a: $arches{$a}\n";
    }

    return 1;
}

=head2 le|list_errata

List all available errata in the channel(s)

=cut

sub list_errata {
    my @args = @_;
    my $channel;
    while ( $channel = shift @args ) {
        my %errata = RHNC::Channel->list_errata( $rhnc, $channel );
        foreach my $erratum ( sort keys %errata ) {
            print
"$erratum ($errata{$erratum}{issue_date}): $errata{$erratum}{synopsis}\n";
        }
    }

    return 1;
}

=head2 llp|list_last_packages

TODO

=cut

sub list_latest_packages {
    my @args = @_;
    my $label_or_id;

    while ( $label_or_id = shift @args ) {
        my $chan = RHNC::Channel::get( $rhnc, $label_or_id );
        my @pkglist = $chan->latest_packages();

        print 'Latest packages for channel ' . $chan->label() . "\n";
        foreach my $pkg (@pkglist) {
            print
"$pkg->{name}-$pkg->{version}-$pkg->{release}-$pkg->{arch_label}: $pkg->{id}\n";
        }
    }

    return 1;
}

=head2 lp|list_packages

List packages (NVRA) in the channel(s)

=cut

sub list_packages {
    my @args = @_;
    my $label_or_id;

    while ( $label_or_id = shift @args ) {
        my $chan = RHNC::Channel::get( $rhnc, $label_or_id );
        my @pkglist = $chan->packages();

        print 'Packages for channel ' . $chan->label() . "\n";
        foreach my $pkg (@pkglist) {
            print
"$pkg->{name}-$pkg->{version}-$pkg->{release}-$pkg->{arch_label}: $pkg->{id}\n";
        }
    }

    return 1;
}

=head2 ls|list_systems

List the systems subscribed to the channel(s).

=cut

sub list_systems {
    my @args = @_;
    my $channel;

    while ( $channel = shift @args ) {
        my %systems = RHNC::Channel->list_systems( $rhnc, $channel );
        foreach my $system ( sort keys %systems ) {
            print "$system: $systems{$system}\n";
        }
    }

    return 1;
}

=head2 rm_packages

TODO

=cut

sub rm_packages {
    my @args = @_;

    carp "not implemented yet";

    return 1;
}

=head1 OPTIONS

Options are specific to each command.


=head1 DIAGNOSTICS

See L<EXIT STATUS>.

=head1 EXIT STATUS

TODO. 
This script will return 1 for success, 0 for failure. Not very
consistent for now, likely to change.

=head1 CONFIGURATION

See L<RHNC>.

=head1 DEPENDENCIES

=over 4

=item *

RHNC

=item *

RHNC::Kickstart

=item *

RHNC::KickstartTree

=back

=head1 INCOMPATIBILITIES

See L<RHNC>.

=head1 BUGS AND LIMITATIONS



=head1 AUTHOR

Jérôme Fenal L<< <jfenal@redhat.com> >>.

=head1 LICENSE AND COPYRIGHT

Copyright 2009, 2010 Jérôme Fenal, all rights reserved.

This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

#
# Main
#

$rhnc = RHNC::Session->new();

#print "API version : ", $rhnc->apiversion(), " | ";
#print "Org ID : ",      $rhnc->org_id(),     "\n";

my @args = @ARGV;
my $cmd  = shift @args;

SWITCH: for ($cmd) {
    m/^(?:ap|AddPackages|add_packages)$/imxs
      && add_packages(@args)
      && last SWITCH;
    m/^(?:c|Create)$/imxs  && create(@args)  && last SWITCH;
    m/^(?:d|Destroy)$/imxs && destroy(@args) && last SWITCH;
    m/^(?:gdp|GetDetailPackages|get_detail_packages)$/imxs
      && get_detail_packages(@args)
      && last SWITCH;
    m/^(?:gd|GetDetails|get_details)$/imxs && get_details(@args) && last SWITCH;
    m/^(?:l|li|lis|list)$/imxs             && list(@args)        && last SWITCH;
    m/^(?:la|ListArches|list_arches)$/imxs && list_arches(@args) && last SWITCH;
    m/^(?:le|ListErrata|list_errata)$/imxs && list_errata(@args) && last SWITCH;
    m/^(?:llp|ListLatestPackages|list_latest_packages)$/imxs
      && list_latest_packages(@args)
      && last SWITCH;
    m/^(?:lp|ListPackages|list_packages)$/imxs
      && list_packages(@args)
      && last SWITCH;
    m/^(?:ls|ListSystems|list_systems)$/imxs
      && list_systems(@args)
      && last SWITCH;
    m/^(?:rp|RmPackages|rm_packages)$/imxs && rm_packages(@args) && last SWITCH;
}

exit 0;

